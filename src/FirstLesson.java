import java.sql.BatchUpdateException;

public class FirstLesson {

    public static void main(String[] args) {
        // точка входа в программу
        // метод main (psvm + enter)
        System.out.println("ку ку!");


        /* тип данных для хранения целых чисел
        short 2 байта от -32768 до 32767
        int 4 байта - 2млр до 2 млр
        long 8 байт
         */

        long longVar = 300000000L;  // добавляется буква L проблема кода выходит за пределы int

        int i = 1_000_000; // можно испольовать нижнее подчеркиванеи для читаемости
        byte byteVar = 12; //создали переменнюю и присвоили значение


        /* числа с плавающей точклй
        float 4 байта
        double 8 байт
         */


        float fl = 10.0f;
        //double do = 10.0;  // использовать предпочтительнее

        // char 2 байта для хранения симоволов, хранит символы в таблице юникода, от 0 до 65535

        // boolean логический тип true/false  , отличается на разных JVM
        boolean bol = true;
        boolean bol1 = false;

        //приведение типов:
        byte someByte = 100;  //тут ничего не происходит
        int someInt = someByte;  // тут сначало приобразовалось к типу int потом присвоилось значение 100

        someInt = 200;
        someByte = (byte) someInt; // тут все ложится на разрабов,
        // будет происходить потеря значения и непредсказуемое приведение
        System.out.println(someByte);
        //тут автоматического приведения не будет, нужно явное приведение типов
        // явно приведение типов не только в примитивных типах
        // (byte) это и есть явное приведение ,
        // типы должны быть совместимы, и менее емкий должен быть в более емкий

        int iggg = 10; //это инструкция, точка с запятой отделяет инструкции


        // операторы
        //  ператоры присваивания
        // = - присвоить  | += | -= | *= | /= | %= арифметическое действие и присвоить
        someByte = 3;
        //someByte = someByte * 7; // тут нужно явное приведение типов
        someByte *= 7; // тут будет происходить явное приведение типов
        someInt = 10;
        someInt = someInt * 7;
        someInt += 20;
        // 7 на 2 при целых числах дробная часть просто отбрасывается

        // арифметические
        // + - / * %(остаток от деления)

        int a = 10, b = 90, c = a + b;
        System.out.println(c);

        short x = 56, y = 77;

        //  short z = x + y;  // результат  сложеиня  byte и short   это int
        int res = x + y; // либо
        long res1 = x + y; //либо
        short z = (short)(x + y); // тут надо операцию брать в скобки (x + y), последовательность действий

        // деление на 0
        int res2 = 100;
        double m = 200.6;

      //  int zeroDiv = res2 / 0; не существует целочисленное деление на 0,
        //  программа дальше работать не будет
       // System.out.println(zeroDiv);
        double zeroDiv2 = m / 0; // бесконечность, и с ней дальше ничего сделать будет нельзя с этим значением
        System.out.println(zeroDiv2);

        // операторы сравнения
        // результат работы операторов сравнения это boolean (true / false)
        // < | > | == | <= | >= | !=
        System.out.println(6 < 22);

        // тернарный операторы ?
        // переменная = (условие) ? выражеине1(если условие истинно) : выражение2 (если условие ложно)
        int k = 4, l = 8;
        int result = (k < l) ? k + l : k - l;

        /*
        дана переменная типа int
        если значение переменной четное .
         */

        int j1 = 5, jjj = ((j1 % 2) == 0) ? j1 / 2 : j1 * 2;
        System.out.println(jjj);
    }
}


//   (ctrl + / ) однострочный комментарий
/*
(ctrl + shift + /)
многострочный комментарий
 */
// (ctrl + alt + L) - выравнивание кода